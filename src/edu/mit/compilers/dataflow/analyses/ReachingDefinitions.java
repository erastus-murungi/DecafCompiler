package edu.mit.compilers.dataflow.analyses;

import java.util.ArrayDeque;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

import edu.mit.compilers.cfg.BasicBlock;
import edu.mit.compilers.dataflow.Direction;
import edu.mit.compilers.dataflow.reachingvalues.DefValue;

public class ReachingDefinitions extends DataFlowAnalysis<DefValue> {
    HashMap<String, HashSet<DefValue>> allDefValues;


    public ReachingDefinitions(BasicBlock basicBlock) {
        super(basicBlock);
    }

    private HashMap<String, HashSet<DefValue>> findAllDefinitions(Set<BasicBlock> visitedBlocks, BasicBlock block){
        HashMap<String, HashSet<DefValue>> defs = new HashMap<>();
        if (!visitedBlocks.contains(block)){
            visitedBlocks.add(block);
            for (DefValue defValue : gen(block)){
                String label = defValue.variableName.value;
                if (defs.containsKey(label)){
                    defs.get(label).add(defValue);
                } else {
                    HashSet<DefValue> placeholder  = new HashSet<>();
                    placeholder.add(defValue);
                    defs.put(label, placeholder);
                }
            }
            for (BasicBlock successor : block.getSuccessors()){
                HashMap<String, HashSet<DefValue>> blockDefs = findAllDefinitions(visitedBlocks, successor);
                for (var entry : blockDefs.entrySet()){
                    var entryName = entry.getKey();
                    if (defs.containsKey(entryName)){
                        defs.get(entryName).addAll(entry.getValue());
                    } else {
                        defs.put(entryName, entry.getValue());
                    }
                }
            }
        }
        return defs;
    }

    @Override
    public void computeUniversalSetsOfValues() {
        allDefValues = findAllDefinitions(new HashSet<>(), this.entryBlock.autoChild);
    }

    @Override
    public Set<DefValue> meet(BasicBlock basicBlock) {
        if (basicBlock.getPredecessors().isEmpty())
            return Collections.emptySet();

        var inSet = new HashSet<DefValue>();

        for (BasicBlock block : basicBlock.getPredecessors())
            inSet.addAll(out(block));

        return inSet;
    }

    @Override
    public Set<DefValue> transferFunction(DefValue domainElement) {
        return null;
    }

    @Override
    public Direction direction() {
        return Direction.BACKWARDS;
    }

    @Override
    public void initializeWorkSets() {
        in = new HashMap<>();
        out = new HashMap<>();

        for (BasicBlock basicBlock: basicBlocks) {
            out.put(basicBlock, new HashSet<>());
            in.put(basicBlock, new HashSet<>());
        }

        out.put(entryBlock, gen(entryBlock));
    }

    @Override
    public void runWorkList() {
        var workList = new ArrayDeque<>(basicBlocks);
        workList.remove(entryBlock);

        while (!workList.isEmpty()) {
            final BasicBlock B = workList.pop();
            var oldOut = out(B);


            // IN[B] = intersect OUT[p] for all p in predecessors
            in.put(B, meet(B));

            // OUT[B] = gen[B] âˆª IN[B] - KILL[B]
            out.put(B, union(gen(B), difference(in(B), kill(B))));

            if (!out(B).equals(oldOut)) {
                workList.addAll(B.getSuccessors());
            }
        }
    }

    public Set<DefValue> gen(BasicBlock basicBlock) {
        // return the set of all the set of definitions generated by the assignments in this basic block
        return basicBlock.getStores().stream().map(DefValue::new).collect(Collectors.toSet());
    }

    public Set<DefValue> kill(BasicBlock basicBlock) {
        HashSet<DefValue> kill = new HashSet<>();
        var genSet = gen(basicBlock);
        for (DefValue defValue: genSet){
            String label = defValue.variableName.value;
            if (allDefValues.containsKey(label)){
               for (DefValue prevDefValue : allDefValues.get(label)){
                   if (!genSet.contains(prevDefValue)){
                       kill.add(prevDefValue);
                   }
               }
            }
        }
        return kill;
    }
}
