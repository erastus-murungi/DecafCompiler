package edu.mit.compilers.dataflow.analyses;

import java.util.ArrayDeque;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

import edu.mit.compilers.cfg.BasicBlock;
import edu.mit.compilers.dataflow.Direction;
import edu.mit.compilers.dataflow.analyses.DataFlowAnalysis;
import edu.mit.compilers.dataflow.usedef.Def;

public class ReachingDefinitions extends DataFlowAnalysis<Def> {
    public ReachingDefinitions(BasicBlock basicBlock) {
        super(basicBlock);
    }

    @Override
    public void computeUniversalSetsOfValues() {
    }

    @Override
    public Set<Def> meet(BasicBlock basicBlock) {
        if (basicBlock.getPredecessors().isEmpty())
            return Collections.emptySet();

        var inSet = new HashSet<Def>();

        for (BasicBlock block : basicBlock.getPredecessors())
            inSet.addAll(out(block));

        return inSet;
    }

    @Override
    public Set<Def> transferFunction(Def domainElement) {
        return null;
    }

    @Override
    public Direction direction() {
        return Direction.BACKWARDS;
    }

    @Override
    public void initializeWorkSets() {
        in = new HashMap<>();
        out = new HashMap<>();

        for (BasicBlock basicBlock: basicBlocks) {
            out.put(basicBlock, new HashSet<>());
            in.put(basicBlock, new HashSet<>());
        }

        out.put(entryBlock, gen(entryBlock));
    }

    @Override
    public void runWorkList() {
        var workList = new ArrayDeque<>(basicBlocks);
        workList.remove(entryBlock);

        while (!workList.isEmpty()) {
            final BasicBlock B = workList.pop();
            var oldOut = out(B);


            // IN[B] = intersect OUT[p] for all p in predecessors
            in.put(B, meet(B));

            // OUT[B] = gen[B] âˆª IN[B] - KILL[B]
            out.put(B, union(gen(B), difference(in(B), kill(B))));

            if (!out(B).equals(oldOut)) {
                workList.addAll(B.getSuccessors());
            }
        }
    }

    private Set<Def> gen(BasicBlock basicBlock) {
        // return the set of all the set of definitions generated by the assignments in this basic block
        return basicBlock.assignments().stream().map(Def::new).collect(Collectors.toSet());
    }

    private Set<Def> kill(BasicBlock basicBlock) {
        // get all definitions
        var genSet = gen(basicBlock);
        // filter and return only re-definitions
        return new HashSet<>(genSet).stream().filter(genSet::contains).collect(Collectors.toSet());
    }
}
