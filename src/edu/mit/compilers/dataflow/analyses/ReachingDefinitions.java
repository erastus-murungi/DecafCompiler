package edu.mit.compilers.dataflow.analyses;

import java.util.ArrayDeque;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

import edu.mit.compilers.cfg.BasicBlock;
import edu.mit.compilers.dataflow.Direction;
import edu.mit.compilers.dataflow.reachingvalues.DefValue;

public class ReachingDefinitions extends DataFlowAnalysis<DefValue> {
    Set<DefValue> allDefValues;


    public ReachingDefinitions(BasicBlock basicBlock) {
        super(basicBlock);
        allDefValues = findAllDefinitions(new HashSet<>(), basicBlock);
    }

    private Set<DefValue> findAllDefinitions(Set<BasicBlock> visitedBlocks, BasicBlock block){
        Set<DefValue> defs = new HashSet<>();
        if (!visitedBlocks.contains(block)){
            visitedBlocks.add(block);
            defs.addAll(gen(block));
            for (BasicBlock successor : block.getSuccessors()){
                defs.addAll(findAllDefinitions(visitedBlocks, successor));
            }
        }
        return defs;
    }

    @Override
    public void computeUniversalSetsOfValues() {
    }

    @Override
    public Set<DefValue> meet(BasicBlock basicBlock) {
        if (basicBlock.getPredecessors().isEmpty())
            return Collections.emptySet();

        var inSet = new HashSet<DefValue>();

        for (BasicBlock block : basicBlock.getPredecessors())
            inSet.addAll(out(block));

        return inSet;
    }

    @Override
    public Set<DefValue> transferFunction(DefValue domainElement) {
        return null;
    }

    @Override
    public Direction direction() {
        return Direction.BACKWARDS;
    }

    @Override
    public void initializeWorkSets() {
        in = new HashMap<>();
        out = new HashMap<>();

        for (BasicBlock basicBlock: basicBlocks) {
            out.put(basicBlock, new HashSet<>());
            in.put(basicBlock, new HashSet<>());
        }

        out.put(entryBlock, gen(entryBlock));
    }

    @Override
    public void runWorkList() {
        var workList = new ArrayDeque<>(basicBlocks);
        workList.remove(entryBlock);

        while (!workList.isEmpty()) {
            final BasicBlock B = workList.pop();
            var oldOut = out(B);


            // IN[B] = intersect OUT[p] for all p in predecessors
            in.put(B, meet(B));

            // OUT[B] = gen[B] âˆª IN[B] - KILL[B]
            out.put(B, union(gen(B), difference(in(B), kill(B))));

            if (!out(B).equals(oldOut)) {
                workList.addAll(B.getSuccessors());
            }
        }
    }

    private Set<DefValue> gen(BasicBlock basicBlock) {
        // return the set of all the set of definitions generated by the assignments in this basic block
        return basicBlock.assignments().stream().map(DefValue::new).collect(Collectors.toSet());
    }

    private Set<DefValue> kill(BasicBlock basicBlock) {
        // get all definitions
        HashMap<String, Set<DefValue>> nameToDefValues = new HashMap<>();
        var defValues = gen(basicBlock);
        for (DefValue defValue : defValues){
            String label = defValue.variableName.label;
            if (nameToDefValues.containsKey(label)){
                nameToDefValues.get(label).add(defValue);
            } else {
                HashSet<DefValue> placeholder  = new HashSet<>();
                placeholder.add(defValue);
                nameToDefValues.put(label, placeholder);
            }
        }
        HashSet<DefValue> kill = new HashSet<>();
        var genSet = gen(basicBlock);
        for (DefValue defValue: genSet){
            String label = defValue.variableName.label;
            if (nameToDefValues.containsKey(label)){
                kill.addAll(nameToDefValues.get(label));
            }
        }
        return kill;
    }
}
